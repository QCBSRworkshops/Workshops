---
title: "Workshop 7: Generalized linear (mixed) models"
subtitle: "QCBS R Workshop Series"
author: "Québec Centre for Biodiversity Science"
output:
  xaringan::moon_reader:
    includes:
      in_header: qcbsR-header.html
    lib_dir: assets
    seal: true
    css: ["default", "qcbsR.css", "qcbsR-fonts.css"]
    nature:
      beforeInit: "qcbsR-macros.js"
      highlightLines: true
---


```{r setup, echo = F}
knitr::opts_chunk$set(
  comment = "#",
  collapse = TRUE,
  cache = TRUE,
  warning = FALSE,
  message = FALSE,
  fig.width=6, fig.height=6,
  fig.align = 'center'
)
mypar = list(mar = c(3,3,1,0.5), mgp = c(1.6, 0.3, 0), tck = -.02)

# add packages
if (!suppressPackageStartupMessages(require(ggplot2))) {
  install.packages("ggplot2")
}
if (!suppressPackageStartupMessages(require(MASS))) {
  install.packages("MASS")
}
if (!suppressPackageStartupMessages(require(binomTools))) {
  # file name
  f = file.path(tempdir(), "biomTools")
  # download package file
  download.file('https://cran.r-project.org/src/contrib/Archive/binomTools/binomTools_1.0-1.tar.gz', destfile = f, method = 'curl')
  # install from source
  system(paste('R CMD INSTALL', f))
}
if (!suppressPackageStartupMessages(require(coefplot2))) {
  install.packages("coefplot2", repos = "http://www.math.mcmaster.ca/bolker/R", type="source")
}
if (!suppressPackageStartupMessages(require(gridExtra))) {
  install.packages("gridExtra")
}
if (!suppressPackageStartupMessages(require(lme4))) {
  install.packages("lme4")
}
if (!suppressPackageStartupMessages(require(lattice))) {
  install.packages("lattice")
}
if (!suppressPackageStartupMessages(require(bbmle))) {
  install.packages("bbmle")
}
```


## Outline

1. Why be normal? .small[(*Your data is ok; it's the model that's wrong*)]
2. GLM with binary data
3. GLM with count data
4. GLMMs

---
class: inverse, center, middle

# Why be normal?

## Your data is ok;
## it's the model that's wrong

---
## Limitations of linear (mixed) models

Load dataset and fit a linear model (`lm()`):

```{r,echo=FALSE}
  mites <- read.csv('data/mites.csv')
```

```{r,eval=F}
  # make sure you're in the right working directory
  mites <- read.csv('mites.csv')
  head(mites)
  str(mites)
```

The dataset that you just loaded is a subset of the 'Oribatid mite dataset'

.small[
> 70 moss and mite samples

> 5 environmental measurements and abundance of the mite *Galumna sp.*
]

**Goal**: Model the abundance (`abund`), occurrence (`pa`), and proportion (`prop`) of Galumna as a function of the 5 environmental variables.

---
## Exploring relationships

Can we see any relationship(s) between Galumna and the 5 environmental variables?

---
## Exploring relationships

.small[Can we see any relationship(s) between Galumna and the 5 environmental variables?]

.pull-left2[
```{r,echo = -1}
  par(mypar)
  plot(mites)
```
]
.pull-right2[
<br><br><br><br><br>
`Galumna` vs `WatrCont`?!
]

---
## Exploring relationships

A negative relationship between `Galumna` and water `content`?

```{r,fig.width=12,fig.height=4.5,echo=-1}
  par(mypar)
  par(mfrow = c(1, 3), cex = 1.4)
  plot(Galumna ~ WatrCont, data = mites, xlab = 'Water content', ylab='Abundance')
  boxplot(WatrCont ~ pa, data = mites, xlab='Presence/Absence', ylab = 'Water content')
  plot(prop ~ WatrCont, data = mites, xlab = 'Water content', ylab='Proportion')
```

---
## Testing linearity

Fit linear models to test whether `abund`, `pa`, and/or `prop` varies as a function of water content.

--
```{r, eval = -c(2, 4, 6)}
  lm.abund <- lm(Galumna ~ WatrCont, data = mites)
  summary(lm.abund)
  lm.pa <- lm(pa ~ WatrCont, data = mites)
  summary(lm.pa)
  lm.prop <- lm(prop ~ WatrCont, data = mites)
  summary(lm.prop)
```

--
.pull-left[
```{r}
summary(lm.abund)$coefficients[, 4]
summary(lm.abund)$coefficients[, 4]
summary(lm.abund)$coefficients[, 4]
```
]
.pull-right[
Significant relationship in all models!

.alert[But...]
]

---
## Testing linearity

Significant relationship in all models! .alert[Wait a minute...]

.pull-left[
```{r,echo=-1}
par(mypar);par(cex = 1.4)
plot(Galumna ~ WatrCont, data = mites)
abline(lm.abund)
```
]

.pull-right[
```{r,echo=-1}
par(mypar)
par(mfrow = c(2, 2), cex = 1.4)
plot(lm.abund)
```
]

---
## Testing linearity

Even worse for other models (Proportion `prop`):

.pull-left[
```{r,echo=-1}
par(mypar);par(cex = 1.4)
plot(prop ~ WatrCont, data = mites)
abline(lm.prop)
```
]

.pull-right[
```{r,echo=-1}
par(mypar)
par(mfrow = c(2, 2), cex = 1.4)
plot(lm.prop)
```
]

---
## Testing linearity

Even worse for other models (Presence/Absence `pa`):

.pull-left[
```{r,echo=-1}
par(mypar);par(cex = 1.4)
plot(pa ~ WatrCont, data = mites)
abline(lm.pa)
```
]

.pull-right[
```{r,echo=-1}
par(mypar)
par(mfrow = c(2, 2), cex = 1.4)
plot(lm.pa)
```
]

---
## Model assumptions

Common in Ecology that assumptions of homogeneity of variance and normality are not met.
  - Main reason why we need GLMs!

.comment[Let's revisit the assumptions of lm...]

---
## Model assumptions

Equation of lm:

$y = \beta_0 + \beta_1x_i + \varepsilon$

where:

$y_i$ = predicted value of response variable

$\beta_0$ = intercept

$\beta_1$ = slope

$x_i$ = explanatory variable

$\varepsilon_i$ = model residuals drawn from a normal distribution with a varying mean but a constant variance**

.comment[.alert[**Key point!] Residuals (the distance between each observation and the regression line) can be predicted by drawing random values from a normal distribution.]

---
## Normally distributed residuals

Recall: Normal distributions have two parameters, $\mu$ (mean) and $\sigma$ (variance):

<br>
.pull-left[
Varing $\mu$, $\sigma = 5$

```{r,echo=F}
x = seq(1, 50, 0.1)
par(mypar);par(cex = 1.4)
plot(x, dnorm(x, mean = 20, sd = 5), type = 'l', lwd = 3, xlab = '# galumna', ylab = 'Probability')
points(x, dnorm(x, mean = 25, sd = 5), type = 'l', lwd = 3, col = 2)
points(x, dnorm(x, mean = 30, sd = 5), type = 'l', lwd = 3, col = 4)
legend('topleft', legend = c('20', '25', '30'), lty = 1, col = 1:3, bty = 'n', lwd = 2, cex = 1.1)
```
]
.pull-right[
$\mu = 25$, varing $\sigma$

```{r,echo=F}
x = seq(1, 50, 0.1)
par(mypar);par(cex = 1.4)
plot(x, dnorm(x, mean = 25, sd = 5), type = 'l', lwd = 3, xlab = '# galumna', ylab = 'Probability')
points(x, dnorm(x, mean = 25, sd = 7.5), type = 'l', lwd = 3, col = 2)
points(x, dnorm(x, mean = 25, sd = 10), type = 'l', lwd = 3, col = 4)
legend('topleft', legend = c('5', '7.5', '10'), lty = 1, col = 1:3, bty = 'n', lwd = 2, cex = 1.1)
```
]

---
## Normally distributed residuals

Another way to write the lm equation is:

$y_i \sim N(\mu = \beta_0 + \beta_1 X_i, \sigma^2)$

<br>
Which literally means that $y_i$ is drawn from a normal distribution with parameters $\mu$ (which depends on $x_i$) and $\sigma$ (which has the same value for all $Y$s)

<br>
.comment[Lets predict Galumna abund as a function of water content using the `lm` we fitted earlier...]

---
## Model prediction

We need regression coefficients ( $\beta$) and $\sigma$:

```{r}
coef(lm.abund)
summary(lm.abund)$sigma
```

What are the parameters of the normal distribution used to model $y$ when water content = 300?

$y_i \sim N(\mu = \beta_0 + \beta_1 X_i, \sigma^2)$

--

$\mu = 3.44 + (-0.006 x 300) = 1.63$

$\sigma = 1.51$

---
## Model prediction

- At $x = 300$, residuals should follow a normal distribution with $\mu = 1.63$ and $\sigma^2 = 1.51$.

- At $x = 400$, we get $\mu = 1.02$ and $\sigma^2 = 1.51$, etc.

<br>
Graphically, this is our model:

--
.pull-left[
.center[
  ![:scale 100%](images/modelPredic.png)
]]
--
.pull-right[
**Problems**:
- $\sigma^2$ is not homogeneous, yet `lm()` forces a constant $\sigma^2$
- Predicted values should be integers
]

---
## Biological data & distributions

Statisticians have described a multitude of distributions that correspond to different types of data

A distribution provides the probability of observing each possible outcome of an experiment or survey (e.g. $abund = 8$ Galumna)

Distributions can be **discrete** (only includes integers
or **continuous** (includes fractions)

All distributions have **parameters** that dictate the shape of the distribution (e.g. $\mu$ and $\sigma^2$ for the normal)

---
## Biological data & distributions

Galumna abund follows a discrete distribution (can only take integer values).

A useful distribution to model abundance data is the “Poisson” distribution:

  - a discrete distribution with a single parameter, $\lambda$ (lambda), which defines both the mean and the variance of the distribution:

```{r,echo=F,fig.width=15}
x = seq(1, 50, 1)
par(mypar);par(mfrow = c(1, 3), cex = 1.4)
plot(x, dpois(x, lambda = 1), type = 'h', lwd = 3, xlab = '# galumna', ylab = 'Probability', main = 'lambda = 1')
plot(x, dpois(x, lambda = 10), type = 'h', lwd = 3, xlab = '# galumna', ylab = 'Probability', main = 'lambda = 10')
plot(x, dpois(x, lambda = 30), type = 'h', lwd = 3, xlab = '# galumna', ylab = 'Probability', main = 'lambda = 30')
```

---
## Biological data & distributions

Galumna seems to follow a Poisson distribution with a low value of $\lambda$:

.pull-left[
```{r}
  hist(mites$Galumna)
```
]
.pull-right[
```{r}
  mean(mites$Galumna)
```
]

---
## Biological data & distributions

Presence-absence takes yet another form:

- only `0`s and `1`s
- Poisson distribution would not be appropriate to model this variable

```{r,fig.height=5,echo=-1}
  par(mypar);par(cex=1.4)
  hist(mites$pa)
```

---
## Biological data & distributions

**“Bernoulli” distribution**:

- Only two possible outcomes in its range: success (`1`) or failure (`0`)
- One parameter, $p$, the probability of success

<br>
```{r,echo=-F,fig.width=12,fig.height=4}
  par(mypar);par(mfrow = c(1, 3), cex=1.4)
  barplot(setNames(c(.9, .1), c('absent (0)', 'present (1)')), ylim = c(0, 1), xlab = 'pa', ylab = 'probability', main = 'p = 0.1')
  barplot(setNames(c(.5, .5), c('absent (0)', 'present (1)')), ylim = c(0, 1), xlab = 'pa', ylab = 'probability', main = 'p = 0.5')
  barplot(setNames(c(.1, .9), c('absent (0)', 'present (1)')), ylim = c(0, 1), xlab = 'pa', ylab = 'probability', main = 'p = 0.9')
```

We can use the Bernouilli distribution to calculate the probability Galumna present (`1`) vs. absent (`0`)

---
## Biological data & distributions

**Binomial distribution**: When there are multiple trials (each with a success/failure), the Bernoulli distribution expands into the binomial
- Additional parameter, n, for number of trials
- Predicts the probability of observing a given proportion of successes, p, out of a known total number of trials, $n$

```{r,echo=F,fig.width=15}
x = seq(1, 50, 1)
par(mypar);par(mfrow = c(1, 3), cex = 1.4)
plot(x, dbinom(x, size = 50, prob = 0.1), type = 'h', lwd = 3, xlab = '# galumna', ylab = 'Probability', main = 'p = 0.1 n = 50')
plot(x, dbinom(x, size = 50, prob = 0.5), type = 'h', lwd = 3, xlab = '# galumna', ylab = 'Probability', main = 'p = 0.5 n = 50')
plot(x, dbinom(x, size = 50, prob = 0.9), type = 'h', lwd = 3, xlab = '# galumna', ylab = 'Probability', main = 'p = 0.9 n = 50')
```

---
## Biological data & distributions

**Binomial distribution**: used to model data where the number of successes are integers and where the number of trials, n, is known.

**Main difference with Poisson distribution**: the binomial has an upper limit to its range, corresponding to `n`. Consequently, it is right-skewed at low p values but left-skewed at high `p` values

```{r,echo=F,fig.width=10, fig.height=5}
x = seq(1, 50, 1)
par(mypar);par(mfrow = c(1, 2), cex = 1.4)
plot(x, dbinom(x, size = 50, prob = 0.9), type = 'h', lwd = 3, xlab = '# galumna', ylab = 'Probability', main = 'p = 0.9 n = 50')
plot(x, dpois(x, lambda = 30), type = 'h', lwd = 3, xlab = '# galumna', ylab = 'Probability', main = 'lambda = 30')
```

---
## Biological data & distributions

Getting back to our problem... can switch the distribution of error terms (εi) from normal to Poisson:

$$y_i \sim Poisson(\lambda = \beta_0 + \beta_1 x_i)$$

Problems solved!

1. $\lambda$ varies with $x$ (water content) which means residual variance will also vary with $x$, which means that we just relaxed the homogeneity of variance assumption!

2. Predicted values will now be integers instead of fractions

3. The model will never predict negative values (Poisson is strictly positive)

---
## Biological data & distributions

This is **almost** a Poisson GLM, which looks like this:

.center[![:scale 90%](images/poisPred.png)]

Probabilities (in orange) are now integers, and both the variance and the mean of the distribution decline as $\lambda$ decreases with increasing water content.


---
class: inverse, center, middle

# GLM with binary data

---
## Binary variables

Common response variable in ecological datasets is the binary variable: we observe a phenomenon X or its “absence”

- Presence/Absence of a species
- Presence/Absence of a disease
- Success/Failure to observe behaviour
- Survival/Death of organisms

Wish to determine if $P/A \sim Environment$ .comment[*]

.comment[Called a logistic regression or logit model]

---
## Binary variables

In `R`, binary variables are coded with `1` and `0`:

```{r,echo=F}
Site <- LETTERS[1:6]
Presence <- c(1, 0, 1, 1, 0, 1)
dat = data.frame(Site, Presence)
```

<br>

.pull-left[
.right[
```{r, echo=F}
print(dat)
```
]]
.pull-right[
 <br>

 1 = Presence

 <br>

 0 = Absence
]

---
## Binary variables

Clearly not normally distributed!

<br>

```{r,echo=F,fig.width=7, fig.height=6}
par(mypar);par(cex = 1.4)
hist(Presence)
```

---
## Binary variables

Expected values can be out of the `[0,1]` range with `lm()`:

<br>

```{r,echo=F,fig.width=7.5, fig.height=5.6}
Pres <- c(rep(1, 40), rep(0, 40))
rnor <- function(x) rnorm(1, mean = ifelse(x == 1, 12.5, 7.5), sd = 2)
ExpVar <- sapply(Pres, rnor)
par(mypar);par(cex = 1.4)
plot(ExpVar, Pres, ylim = c(-.5, 1.5), xlab = 'Explanatory variable', ylab = 'Presence', main = 'Binary variables and fitted values with lm()', pch = 16)
abline(lm(Pres ~ ExpVar), col = 'orange', lwd = 2)
mtext(expression(symbol("\255")), at = 1.25, side = 4, line = 0.1, cex = 6, col = 'blue')
mtext(expression(symbol("\256")), at = 3, side = 1, line = -2.2, cex = 6, col = 'blue')
```

---
## Probability distribution

The Bernoulli distribution is well suited for binary response variables

<br>

.pull-left[.right[

$E(Y) = p$

<br>

$Var(Y) = p \times (1 - p)$

]]
.pull-right[

![:faic](arrow-right) **Mean of distribution** .small[Probability $p$ of observing an outcome]

![:faic](arrow-right) **Variance of distribution** .small[Variance decreases as $p$ is close to `0` or `1`]
]

---
## Logistic regression

The `glm()` function!

<br>

`logit.reg <- glm(formula, data, family)`

<br>

To move away from traditional linear models, need to specify two things (`family`):

1. probability distribution

**AND**

2. a link function

---
## The Link Function

For a simple linear model of a normally distributed continuous response variable, the equation for the expected values is:

<br>

$$\mu = x\beta$$

where

- $\mu$ is the expected value of the response variable
- $x$ is the model matrix (*i.e.* your data)
- $\beta$ is the vector of estimated parameters (*i.e.* the intercept & slope)

<br>

$x\beta$ is called the **linear predictor**

---
## The Link Function

$\mu = x\beta$ is only true for normally distributed data

If this is not the case, must use a transformation on the expected values $\mu$

$$g(\mu) = x\beta$$

where $g(\mu)$ is the link function

<br>

This allows us to relax the normality assumption

---
## The Link Function

For binary data, the link function is called the **logit**:

<br>

$$g(\mu) = log\frac{\mu}{1-\mu}$$

$\mu =$ expected values (probability that $Y = 1$)

<br>

- Get the odds ( $\frac{\mu}{1-\mu}$)
- log-transform them

---
## The Link Function

$$g(\mu) = log\frac{\mu}{1-\mu}$$

- Get the odds ( $\frac{\mu}{1-\mu}$)
- log-transform them

<br>
The odds puts our expected values on a `0` to `+Inf` scale

The log transformation puts our expected values on a `-Inf` to `+Inf`

![:faic](arrow-right) The expected values can now be **linearly** related to the linear predictor

---
## Exercise 1

Build a logistic regression model using the mites data

```{r,eval=F}
#setwd('...')
mites <- read.csv("mites.csv", header = TRUE)
str(mites)

```{r,echo=F}
mites <- read.csv("data/mites.csv", header = TRUE)
str(mites)
```

---
## Exercise 1

Build a model of the presence of Galumna sp. as a function of water content and topography

```{r}
logit.reg <- glm(pa ~ WatrCont + Topo, data=mites,
family = binomial(link = "logit"))
```
```{r,eval=F}
summary(logit.reg)
```

---
## Exercise 1

.small[
```{r}
summary(logit.reg)
```
]

---
## Challenge 1 ![:cube]()

Using the 'bacteria' dataset, model the presence of *H. influenzae* as a function of treatment and week of test.

Start with a full model and reduce it to the most parsimonious model.

```{r}
#install.packages("MASS")
library(MASS)
data(bacteria)
str(bacteria)
```

---
## Solution ![:cube]()

```{r}
model.bact1 <- glm(y ~ trt * week, data = bacteria, family = binomial)
```

```{r}
model.bact2 <- glm(y ~ trt + week, data = bacteria, family = binomial)
```

```{r}
model.bact3 <- glm(y ~ week, data = bacteria, family = binomial)
```

```{r}
anova(model.bact1, model.bact2, model.bact3, test = "LRT")
```

---
## Interpreting the output

Let's go back to the summary of our `logit.reg` model to see the coefficients:

```{r}
summary(logit.reg)$coefficients
```

The output indicates that both water content and topography are significant

.comment[But how do we interpret the slope coefficients?]

---
## Interpreting the output

Remember we used a logit transformation on the expected values!

To properly interpret the regression parameters, we have to use a 'reverse' function:

<br>
The natural exponential function to obtain the odds: $e^x$

The inverse logit function to obtain the probabilities:

$$logit^{-1} = \frac{1}{1 + \frac{1}{e^x}}$$

---
## Interpreting the output

On the odds scale for water content:

```{r}
exp(logit.reg$coefficient[2])
```

On the probability scale for water content:

```{r}
1 / (1 + 1/exp(logit.reg$coefficient[2]))
```

---
## Predictive Power and goodness of fit

Get the pseudo-R², the analogue of the $R^2$ for models fitted by maximum likelihood:

$$\text{pseudo-R}^2 = \frac{\text{null deviance - residual deviance}}{\text{null deviance}}$$

<br>

$\text{pseudo-R}^2 = \text{variance explained by the model}$

---
## Predictive Power and goodness of fit

Comparing deviance of your model (residual deviance) to the deviance of a null model (null deviance)

The **null model** is a model without explanatory variables

```R
null.model <- glm(Response.variable ~ 1, family = binomial)
```

---
## Predictive Power and goodness of fit

In R, we can extract the residual and null deviances directly from the glm object:

```{r}
objects(logit.reg)
```

```{r}
pseudoR2 <- (logit.reg$null.deviance - logit.reg$deviance) / logit.reg$null.deviance
pseudoR2
```

.comment[Hence, the model explains 46.6% of the variability in the data]

---
## Predictive Power and goodness of fit

New statistic - **coefficient of discrimination (D)** evaluates the predictive power of logistic regression

- Measure of how well logistic regression classifies an outcome as a success or a failure

To assess goodness of fit, diagnostic plots are not useful, instead must use **Hosmer-Lemeshow test**:

- Compare observed and expected number of outcomes
- Similar to a Chi square test

---
## Exercise 2

In R these tests are available in the `binomTools` package

Compute the coefficient of discrimination D

```{r}
fit <- binomTools::Rsq(object = logit.reg)
fit
```

---
#### Exercise 2: Perform a Hosmer-Lemeshow test .comment[*]

.small[
```{r}
binomTools::HLtest(binomTools::Rsq(model.bact2))
```
]

.comment[A non significant value indicates an adequate fit!]

---
## Challenge 1 ![:cube]()

1. Using the model created with bacteria dataset, assess goodness of fit and predictive power.

2. Think how predictive power could be improved for this model.

---
## Solution ![:cube]()

1:
```{r,eval=F}
null.d <- model.bact2$null.deviance
resid.d <- model.bact2$deviance
bact.pseudoR2 <- (null.d -resid.d) / null.d
HLtest(Rsq(model.bact2)
```

2: Adding informative explanatory variables could increase the explanatory power of the model

---
## Proportion data and GLM

Sometimes, proportion data is more similar to logistic regression than you think...

If we measure the number of occurrences and we know the total sample size, it is not count data!

Suppose we measure disease prevalence in ten deer populations on 10 deer individuals per population:


.pull-left[

$$\frac{x\,\, \text{infected deer}}{10\,\,\text{deer}}$$

]

.pull-right[
![:faic](arrow-right) always bound between `0` and `1`!
]

---
## Exercise 3

In R, we have to specify the number of times something happened and the number of times something did not happen:

```{r}
prop.reg <- glm(cbind(Galumna, totalabund - Galumna) ~ Topo + WatrCont, data = mites, family = binomial)
```

```r
summary(prop.reg)
```

---
## Exercise 3

.small[
```{r}
summary(prop.reg)
```
]

---
## Exercise 3

We can also code the model directly with proportions :

```{r}
prop.reg2 <- glm(prop ~ Topo + WatrCont, data = mites,
                 family = binomial, weights = totalabund)
```


---
class: inverse, center, middle

# GLM with count data

---
## Modeling count data

.large[What is count data?]

Import the `faramea.csv` into R

```{r,echo=F}
faramea <- read.csv('data/faramea.csv', header = TRUE)
```
```{r,eval=F}
faramea <- read.csv('faramea.csv', header = TRUE)
```

The number of trees of the species *Faramea occidentalis* was assessed in 43 quadrats in Barro Colorado Island (Panama). For each quadrat, environmental characteristics were also recorded such as elevation or precipitation.

Let's investigate the histogram of the number of *Faramea occidentalis*

---
## Modeling count data

.large[What is count data?]

```{r, echo=F,fig.height=4.6}
par(mypar);par(cex = 1.4)
hist(faramea$Faramea.occidentalis, breaks = 30, col = 'gray', xlab = 'Number of F. occidentalis', ylab = 'Frequency', main = '')
```

Count data are characterized by:

- positive values: you do not count -7 individuals
- integer values: you do not count 7.56 individuals
- exhibits larger variance for large values

---
## Modeling count data

.large[How to model count data?]

Does elevation influence the abundance of *F. occidentalis*?

```{r, echo=F,fig.height=4.6}
par(mypar);par(cex = 1.4)
plot(faramea$Elevation, faramea$Faramea.occidentalis, ylab = 'Number of F. occidentalis', xlab = 'Elevation(m)')
```

the **Poisson distribution** seems to be the perfect choice to model this data, hence **Poisson GLMs** are usually the good way to start modeling count data.

---
## The Poisson distribution

The Poisson distribution specifies the probability of a discrete random variable Y and is given by:

$$f(y, \,\mu)\, =\, Pr(Y = y)\, =\, \frac{\mu^y \times e^{-\mu}}{y!}$$

$$E(Y)\, =\, Var(Y)\, =\, \mu$$

**Properties**:

- $\mu$ is the parameter of the Poisson distribution
- specifies the probably only for integer values
- probability for negative values is null ( $P(Y<0) = 0$)
- mean = variance (allows for heterogeneity)

---
## Poisson GLM behind the scenes

A Poisson GLM will model the value of µ as a function of different explanatory variables

<br>

.center[**Three steps**]

**Step 1.** We assume Yi follows a Poisson distribution with mean and variance $\mu_i$

$$Y_i = Poisson(\mu_i)$$

$$E(Y_i) = Var(Y_i) = \mu_i$$

$$f(y_i, \, \mu_i) = \frac{\mu^{y_i}_i \times e^{-\mu_i}}{y!}$$

$\mu_i$ corresponds to the expected number of individuals

---
## Poisson GLM behind the scenes

**Step 2.** We specify the systematic part of the model just as in a linear model
Interpreting the output

$$\underbrace{\alpha}_\text{One intercept} + \underbrace{\beta}_\text{slope of 'Elevation'} \times \text{Elevation}_i$$

**Step 3.** The link between the mean of $Y_i$ and the systematic part is a logarithmic

$$log(\mu_i) = \alpha + \beta \times \text{Elevation}_i$$

.center[or]

$$\mu_i = e^{ \alpha + \beta \times \text{Elevation}_i}$$

---
## Fitting a Poisson GLM in R

The function `glm()` allows you to specify a Poisson GLM

```{r}
glm.poisson = glm(Faramea.occidentalis~Elevation, data=faramea, family=poisson)
```

`family` argument specify the distribution and link function

<br>

As with `lm()` you can access the outputs of the model using the function `summary()`

```{r,eval=F}
summary(glm.poisson)
```

---
## Model summary

.pull-left2[
.small[
```{r}
summary(glm.poisson)
```
]]

.pull-right2[
Estimates:

Intercept = $\alpha$

Elevation = $\beta$

]

--

.pull-right2[
<br>
What about `Null deviance` and `Residual deviance`?!
]


---
## Parameter estimates

In our model the unknown parameters are the intercept ( $\alpha$) and the slope of elevation ( $\beta$)


$$log(\mu_i) = 1.769 - 0.0027 \times \text{Elevation}_i$$

.center[or]

$$\mu_i = e^{1.769 - 0.0027 \times \text{Elevation}_i}$$


---
## The deviance

Remember that to estimate the unknown parameters maximum likelihood estimation is used

The residual deviance is defined as twice the difference between the log likelihood of a model that provides a perfect fit and the log likelihood of our model

$$\text{Res dev} = 2 \, log(L(y;\,y)) - 2 \, log(L(y;\, \mu))$$

In a Poisson GLM, the residual deviance should equal the residual degrees of freedoms

.center[.alert[388.12 >> 41]]


---
## Overdispersion

When the residual deviance is higher than the residual degrees of freedom we say that the model is **overdispersed**

$$\phi \, = \, \frac{\text{Residual deviance}}{\text{Residual degrees of freedom}}$$

Occurs when the variance in the data is even higher than the mean, hence the Poisson distribution is not the best choice (many zeros, many very high values, missing covariates, etc)

.center[.large[**Solutions**]]

.pull-left[
1: Correct for overdispersion using **quasi-Poisson GLM**
]

.pull-right[
2: Choose another distribution: **the negative binomial**
]

---
## Quasi-Poisson GLM

The variance of the distribution will account for **overdispersion**:

$$E(Y_i) = \mu_i$$

$$Var(Y_I) = \phi \times \mu_i$$

the **systematic part** and the **link function** remain the same

$phi$ is the dispersion parameter. It will be estimated prior to estimate parameters. Correcting for overdispersion will not affect parameter estimates but will affect their **significance**. Indeed, the standard errors of the parameters are multiplied by $\sqrt{\phi}$

.alert[Some marginally significant p-values may no longer hold!]

---
## Fitting a quasi-Poisson GLM in R

Create a new GLM using the 'quasipoisson' family or update the previous one

```{r}
glm.quasipoisson = glm(Faramea.occidentalis ~ Elevation, data = faramea,
                       family=quasipoisson)
glm.quasipoisson = update(glm.poisson, family = quasipoisson)
```

---
## Fitting a quasi-Poisson GLM in R

.pull-left2[
.small[
```{r}
summary(glm.quasipoisson)
```
]]
.pull-right2[
**Same estimates but**

.small[The standard errors of the parameters are multiplied by]

$$\sqrt{\phi} = 4$$

`0.0006436 * 4 = 0.00257`

<- $\phi$

<br>

<- .small[AIC is not defined]
]

---
## Fitting a quasi-Poisson GLM in R

Try also deviance analysis to test for the effect of Elevation

```{r}
null.model <- glm(Faramea.occidentalis ~ 1, data = faramea,
                  family = quasipoisson)
anova(null.model, glm.quasipoisson, test = "Chisq")
```

---
## Dispersion parameter

.center[![:scale 80%](images/dispParam.png)]

---
## Negative binomial GLM

Negative binomial GLMs are favor when overdispersion is high

- It has **two parameters** $\mu$ and $k$. $k$ controls for the dispersion parameter (smaller $k$ indicates higher dispersion)
- It corresponds to a combination of two distributions (**Poisson** and **gamma**)
- It assumes that the $Y_i$ are Poisson distributed with the mean $\mu$ assumed to follow a gamma distribution!

$$E(Y_i) = \mu_i$$

$$Var(Y_i) = \mu_i + \frac{\mu^2_i}{k}$$


---
## Fitting a negative binomial in R

NB is not in the `glm()` function so you need to install and charge the `MASS` package

```r
install.packages('MASS')
```

```{r}
glm.negbin = glm.nb(Faramea.occidentalis ~ Elevation, data = faramea)
```

```r
summary(glm.negbin)
```

---

.pull-left2[
.small[
```{r,echo=-1}
summary(glm.negbin)
```
]]
.pull-right2[

<br><br><br><br><br><br><br><br><br><br><br><br><br>
`theta` $= k$
]

---
## Plotting the final GLM model

**Step 1** Plot the data and the use estimates of the parameters to draw model line

$$\mu_i = e^{2.369 - 0.007 \times Elevation_i}$$

Use `summary()` to get the parameters

```r
summary(glm.negbin)$coefficients[1, 1]
summary(glm.negbin)$coefficients[2, 1]
```

**Step 2** Use the standard errors to build the confidence envelope

```r
summary(glm.negbin)$coefficients[1, 2]
summary(glm.negbin)$coefficients[2, 2]
```

$$\text{Upper limit} = e^{[\alpha - 1.96 \times SE_{\alpha}] + [\beta - 1.96 \times SE_{\beta}] \times \text{Elevation}_i}$$

$$\text{Upper limit} = e^{[\alpha + 1.96 \times SE_{\alpha}] + [\beta + 1.96 \times SE_{\beta}] \times \text{Elevation}_i}$$

---
.small[
```{r,eval=F}
pp <- predict(glm.negbin, newdata = data.frame(Elevation = 1:800), se.fit = TRUE)
linkinv <- family(glm.negbin)$linkinv ## inverse-link function
pframe$pred0 <- pp$fit
pframe$pred <- linkinv(pp$fit)
sc <- abs(qnorm((1-0.95)/2))  ## Normal approx. to likelihood
pframe <- transform(pframe, lwr = linkinv(pred0-sc*pp$se.fit), upr = linkinv(pred0+sc*pp$se.fit))

plot(faramea$Elevation, faramea$Faramea.occidentalis, ylab = 'Number of F. occidentalis', xlab = 'Elevation(m)')
lines(pframe$pred, lwd = 2)
lines(pframe$upr, col = 2, lty = 3, lwd = 2)
lines(pframe$lwr, col = 2, lty = 3, lwd = 2)
```
]

```{r,echo=F, fig.height=5}
pframe <- data.frame(Elevation = 1:800)
pp <- predict(glm.negbin, newdata = pframe, se.fit = TRUE)
linkinv <- family(glm.negbin)$linkinv ## inverse-link function

pframe$pred0 <- pp$fit
pframe$pred <- linkinv(pp$fit)
alpha <- 0.95
sc <- abs(qnorm((1-alpha)/2))  ## Normal approx. to likelihood
alpha2 <- 0.5
pframe <- transform(pframe,
                    lwr=linkinv(pred0-sc*pp$se.fit),
                    upr=linkinv(pred0+sc*pp$se.fit))

par(mypar);par(cex = 1.4)
plot(faramea$Elevation, faramea$Faramea.occidentalis,
      ylab = 'Number of F. occidentalis', xlab = 'Elevation(m)')
lines(pframe$pred, lwd = 2)
lines(pframe$upr, col = 2, lty = 3, lwd = 2)
lines(pframe$lwr, col = 2, lty = 3, lwd = 2)
```

---
## Challenge 3 ![:cube]()

Use the `mites` dataset! Model the abundance of the species Galumna as a function of the substrate characteristics (water content `WatrCont` and density `SubsDens`)

- Do you need to account for overdispersion?
- Which covariates have a significant effect?
- Select the best model!

```{r,echo=F}
mites <- read.csv("data/mites.csv", header = TRUE)
```
```{r,eval=F}
mites <- read.csv("mites.csv", header = TRUE)
```

---
## Challenge 3: tips ![:cube]()

Drop each term in turn and compare the full model with a nested model using the command:

```r
drop1(MyGLM, test = "Chi")
```

Specify manually a nested model, call it for example MyGLM2, and use the command:

```r
anova(MyGLM, MyGLM2, test = "Chi")
```

---
## Challenge 3: solution ![:cube]()

.small[
```{r}
# Poisson GLM
glm.p = glm(Galumna~WatrCont+SubsDens, data=mites, family=poisson)
# quasi-Poisson GLM
glm.qp = update(glm.p,family=quasipoisson)
# model selection
drop1(glm.qp, test = "Chi")
```
```r
# or
glm.qp2 = glm(Galumna~WatrCont, data=mites, family=quasipoisson)
anova(glm.qp2, glm.qp, test="Chisq")
```
]


---
## Challenge 3: solution ![:cube]()

<br>

.center[
```{r,echo=F, fig.height=5,fig.width=6}
glm.qp = glm(Galumna~WatrCont, data=mites, family=poisson)
glm.qp2 = update(glm.qp, family=quasipoisson)
pframe <- data.frame(WatrCont = 100:850)
pp <- predict(glm.qp2, newdata = pframe, se.fit = TRUE)
linkinv <- family(glm.qp2)$linkinv ## inverse-link function

pframe$pred0 <- pp$fit
pframe$pred <- linkinv(pp$fit)
alpha <- 0.95
sc <- abs(qnorm((1-alpha)/2))  ## Normal approx. to likelihood
alpha2 <- 0.5
pframe <- transform(pframe,
                    lwr=linkinv(pred0-sc*pp$se.fit),
                    upr=linkinv(pred0+sc*pp$se.fit))

par(mypar);par(cex = 1.4)
plot(mites$WatrCont, mites$Galumna,
      ylab = 'Number of Galumna', xlab = 'Water content of the substrate (g/L)')
lines(pframe$pred, lwd = 2)
lines(pframe$upr, col = 2, lty = 3, lwd = 2)
lines(pframe$lwr, col = 2, lty = 3, lwd = 2)
```
]


---
## Other distributions

- **Logit transformation of the data** often used with `lm(m)` for percentages or proportions when the binomial distribution is not appropriate. When not selections from fixed quantities (e.g. percent cover, school grades, etc).
- **Log-normal distribution in glm**, avoids having to log-transform the data.
- **Gamma distribution**. Similar to log-normal, more versatile.
- **Tweedie distribution**. Versatile family of distributions. Useful for data with a mix of zeros and positive values (not necessarily counts).
- **Zero-inflated Poisson or zero-inflated negative binomial**. When the data comprise an excess number of zeros, that arise from a different process than the process that generates the counts.

---
class: inverse, center, bottom

# Thank you for attending this workshop!

![:scale 50%](images/QCBS_logo.png)
